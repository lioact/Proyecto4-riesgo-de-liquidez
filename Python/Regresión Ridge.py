# -*- coding: utf-8 -*-
"""Ridge

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nOppCsWPsXLjYvAvd_ahcgEki9RDeCRw
"""

# Importar librerías
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import RidgeCV
from sklearn.metrics import r2_score
from scipy.stats import spearmanr
import warnings

warnings.filterwarnings("ignore")


# Cargar variables macroeconómicos

# Ruta relativa desde el directorio del script
ruta_macro = 'Datos/df_series.xlsx'
ruta_bancos = 'Datos/Proyecto 4 Cuentas de Captación 2024.xlsx'

# Leer archivo
datos = pd.read_excel(ruta_macro, sheet_name="Datos")
def cargar_filtrar(sheet_name):
    df = pd.read_excel(ruta_bancos, sheet_name=sheet_name)
    df['Fecha'] = pd.to_datetime(df['Fecha'])
    return df[(df['Fecha'] >= "2019-12-01") & (df['Fecha'] <= "2024-06-01")]

# Cargar cada banco
TBM = cargar_filtrar("TBM")
BX = cargar_filtrar("Banamex")
BBVA = cargar_filtrar("BBVA")
SA = cargar_filtrar("Santander")
BN = cargar_filtrar("Banorte")

# Unir con datos macro
TBM2 = pd.merge(TBM, datos, on="Fecha", how="left")
BX2 = pd.merge(BX, datos, on="Fecha", how="left")
BBVA2 = pd.merge(BBVA, datos, on="Fecha", how="left")
SA2 = pd.merge(SA, datos, on="Fecha", how="left")
BN2 = pd.merge(BN, datos, on="Fecha", how="left")

def ajustar_y_analizar_ridge(df, banco, variable_respuesta, variables_predictoras):
    print(f"\n\nModelo Ridge: {banco} - {variable_respuesta}")

    columnas = ["Fecha", variable_respuesta] + variables_predictoras
    df = df[columnas].dropna()

    X = df[variables_predictoras].values
    y = df[variable_respuesta].values

    if y is None or np.var(y) == 0:
        print(f"Variable {variable_respuesta} inválida (NULL o constante)")
        return None

    # Escalado
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    # Ajuste Ridge con validación cruzada
    modelo = RidgeCV(alphas=np.logspace(-6, 6, 100), store_cv_values=True)
    modelo.fit(X_scaled, y)
    y_hat = modelo.predict(X_scaled)

    # Generar DataFrame para graficar más adelante
    df_plot = pd.DataFrame({
        "Fecha": df["Fecha"],
        "Serie": variable_respuesta,
        "Real": y,
        "Estimado": y_hat
    })

    return df_plot

# Diccionario con tus DataFrames por banco
bancos = {
    "TBM": TBM2,
    "Banamex": BX2,
    "BBVA": BBVA2,
    "Santander": SA2,
    "Banorte": BN2
}

variables_captacion = ["Depositos Vista", "Depositos Plazo", "Captación tradicional"]
variables_macro = ["TIIE", "FIX", "Base_Monetaria", "Remesas_Familiares", "INPC",
                   "Costo_Captacion", "Agregados_Monetarios", "Activos_Financieros"]

for banco, df_banco in bancos.items():
    df_graficas = pd.DataFrame()

    for var_resp in variables_captacion:
        if var_resp in df_banco.columns:
            df_r = ajustar_y_analizar_ridge(df_banco, banco, var_resp, variables_macro)
            if df_r is not None:
                df_graficas = pd.concat([df_graficas, df_r], ignore_index=True)

    if not df_graficas.empty:
        df_long = df_graficas.melt(
            id_vars=["Fecha", "Serie"],
            value_vars=["Real", "Estimado"],
            var_name="Tipo",
            value_name="Valor"
        )

        g = sns.FacetGrid(df_long, col="Serie", hue="Tipo", height=4, aspect=1.8, sharey=False)
        g.map(sns.lineplot, "Fecha", "Valor", linestyle="--")
        g.add_legend()
        g.set_titles(col_template="{col_name}")
        g.fig.suptitle(f"Modelo Ridge - {banco}", fontsize=16)
        g.fig.tight_layout(rect=[0, 0, 1, 0.96])
        plt.show()



def ajustar_y_analizar_ridge(df, banco, variable_respuesta, variables_predictoras):
    columnas = ["Fecha", variable_respuesta] + variables_predictoras
    df = df[columnas].dropna()

    X = df[variables_predictoras].values
    y = df[variable_respuesta].values

    if y is None or np.var(y) == 0:
        print(f"Variable {variable_respuesta} inválida (NULL o constante)")
        return None

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    modelo = RidgeCV(alphas=np.logspace(-6, 6, 100), store_cv_values=True)
    modelo.fit(X_scaled, y)
    y_hat = modelo.predict(X_scaled)

    r2 = r2_score(y, y_hat)
    rho, p_valor = spearmanr(y, y_hat)
    coef_ridge = dict(zip(variables_predictoras, modelo.coef_))

    return {
        "modelo": modelo,
        "r2": r2,
        "alpha": modelo.alpha_,
        "coeficientes": coef_ridge,
        "spearman": {"rho": rho, "p_valor": p_valor},
        "banco": banco,
        "variable": variable_respuesta
    }

todos_los_modelos = []

for banco, df_banco in bancos.items():
    for var_resp in variables_captacion:
        if var_resp in df_banco.columns:
            resultado = ajustar_y_analizar_ridge(df_banco, banco, var_resp, variables_macro)
            if resultado is not None:
                todos_los_modelos.append(resultado)

for res in todos_los_modelos:
    print(f"\n Banco: {res['banco']} | Variable: {res['variable']}")
    print(f"R²: {res['r2']:.4f}")
    print(f"Lambda óptimo (alpha): {res['alpha']:.6f}")
    
    print("Coeficientes:")
    for var, coef in res['coeficientes'].items():
        signo = "positiva ↑" if coef > 0 else "negativa ↓" if coef < 0 else "nula –"
        print(f"  - {var}: {coef:.4f} ({signo})")
    
    print(f" Spearman rho = {res['spearman']['rho']:.4f}, p-valor = {res['spearman']['p_valor']:.4g}")

